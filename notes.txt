Link
Dzieki tagom Link używanym zamiast <a>, używami client-side navigation dzięki czemu przechodzenie między podstronami nie powoduje pełnego przeładowania strony, re-renderowane są tylko elementy, które uległy zmianie 

Data Fetching

1. Przez API
    Sytuacje, w których używami API:
    - Używamy third-party, czyli oddzielnych serwisów dostarczających API
    - Bierzemy dane od użytkownika, które powinny być przesyłane za pomocą api, aby uniknąć różnych problemów związanych z bezpieczeństwem i uniknąć np. SQL Injection, za pomocą walidacji danych itp.
    W Next.js możemy tworzyć API endpoints za pomocą Route Handlers. Pliki routes pozwalają nam na tworzenie różnych funkcji obsługujących różne metody HTTP, np. GET, POST, PUT, DELETE.
    export async function GET(request: Request) {}
    
    export async function HEAD(request: Request) {}
    
    export async function POST(request: Request) {}
    
    export async function PUT(request: Request) {}
    
    export async function DELETE(request: Request) {}
    
    export async function PATCH(request: Request) {}
    
    // If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.
    export async function OPTIONS(request: Request) {}

    Parametr request to obiekt typu NextRequest, będący rozszerzeniem standardowego request, który dostarcza więcej kontroli nad nadchodzącym zapytaniem http jak dostęp do cookies i URL object

2. Przed database queries
    PRzy relacyjnej bazie danych jak postresql, możemy robić to za pomocą SQL lub ORM 
    Kiedy tworzymy database queries:
    - Tworzymy endpointy API, musimy napisać logikę obsługi bazy danych
    - Gdy używamy React Server components, możemy pisać queries bezpośrednio w komponencie, ponieważ są one wykonywane po stronie serwera a nie klienta

Biblioteka postgres.js dostarcza zabezpieczenia przeciw SQL Injection

1. Normalne wykonywanie zapytań
    Zapytania data requests mogą przypadkowo blokować się nawazajem, powodująć request waterfall
        Co to ? 
        Wodospad odnosi się do kolejności  wykonywania zapytań polegającej na tym, że następne zapytanie może zacząć się tylko jeśli poprzednie dostało swoje dane.
        Czyli robimy np. await fetchData(), a potem mamy await fetchData2(), czyli najpierw wykonuje sie zapytanie 1 i następne czekają na jego zakończenie

2. Parallel data fetching, czyli równoległe pobieranie danych
    Sposób zapobiegania Wodospadom, polegający na jednoczesnym wykonywaniu zapytań. Czyli:
    1. Tworzysz obiekty Promise :  const data1 = sql'Select * from clients'; const data2 = .....
    2. Potem wykonujesz te zapytania wszystkie naraz za pomocą Promise.all()
        const allData = await Promise.all([ data1, data2, data3 ])

    Dzięki temu ładowanie strony i wszystkich danych jest szybsze, ale nie używamy tego jak np. następne dane zależą od poprzednich czyli najpierw pobieramy uzytkownika, a potem np. jego znajomych, ponieważ najpierw musimy znać użytkownika aby dostać się do jego znajomych

Static Rendering
Przy statycznym renderowaniu, dane pobierane są na serwerze w trakce build time, a nie przy każdym zapytaniu.
Używa się go gdy robimy UI bez danych pobieranych lub bez danych wymienianych między użytkownikami.

Dynamic Rendering
Strona jest renderowna przy każdym requescie od uzytkownika, a nie raz na jakis czas

Static używamy gdy robimy np. stron e wizytowke, jakiegos bloga itp. gdzie dane nie muszą być aktualizowane często, a Dynamic gdy mamy np. taki dashboardze statystykami i chcemy aby były one na bieżąco atkuzalizowane.

Problem z Dynamic jest taki, że pochłania więcej zasobów serwera, poniewaz strona jest rerenderowana przy każdym requescie i strona jest tak szybka jak nasz najwolniejszy fetch(), ponieważ dopóki dane nie zostaną pobrane to strona się nie wyswietli.


Streaming
    Streaming pozwala na przesyłanie danych do klienta w kawałkach, a nie w całości, dzięki czemu slow data requests nie blokują nam ładowana strony, dzięki czemu użytkownik widzi wcześniej już UI i pojedyncze elementy, a nie musi czekać aż całość się załaduje
    Działa to dobrze w Reactowymi komponentami, ponieważ każdy komponent może być przesyłany osobno jako kawałek danych.
    Jak sie robi Streaming w nextjs ?
        1. Uzywamy mechanizmu React Suspense, tworząc loading.tsx na poziome naszej strony, który renderuje się natychmiastowo i automatycznie tworzy za nas <Suspense>
        2. Streaming na poziomie komponentu - można streamować tylko fragment strony, za pomocą <Suspense>, czyli:
            export default function Page() {
                return (
                    <>
                    <Header />

                    <Suspense fallback={<p>Loading comments...</p>}> //komponent Comments jest opakowany w suspense, co skutkuje tym ze nasz komponent header zaladuje sie od razu ale po prostu w miejscu komponentu Comments bedziemy miec "Loading comments..." wyświetlony na czas ładowania.
                        <Comments />
                    </Suspense>
                    </>
                )
            }

Używanie URL params 
URL params to /dashboard?query=apple&page=2 parametry po znaku "?", czyli query = apple i page = 2
Za ich pomocą możemy zarządzać search state, czyli zamiast trzymac stan wyszukiwania przez useState() to trzymamy go w url, czyli ...?query=apple
Dlaczego uzywać ?
    1. Bookmarkable i shareable - bez url params parametr wyszukiwania zniknie po odswiezeniu strony, bedzie default
    2. SSR - serwer widzi url, a nie widzi React state, więc bez url params nie jest mozliwy server side Rendering
    3. Analytics and tracking - wyszukiwania zapisują się w logach, więc można śledzić zachowanie użytkowników bez dodatkowej logiki po stronie klienta 
Używanie:
    - useSerachParams - pozwala na dostęp do parametrów z adresu URL
    - usePathname - pozwala odczytać obecny URL czyli jak mamy /dashboard/invoices to zwróci nam '/dashboard/invoices'
    - useRouter - pozwala zmieniać trasę URL i nawigować między stronami z poziomu kodu, czyli po prostu zmieniać storny


DEBOUNCING
Wazne przy wyszukiwaniu, zeby nie pobierac danych przy kazdym wpisaniu znaku, uzywa sie do tego use-debounce

Next i Server Actions
    Server Actions pozwala na wywoływanie asynchronicznego kodu na serwerze, dzieki czemu eliminują potrzebę tworzenia API do CRUD (jeżeli modyfikujemy i pobieramy dane po stronie klienckiej to powinno byc to robione przez API)
    Jak używamy?
        Tworząc funkcję np. w pliku actions.ts markujemy funkcje jako server actions dodajac na górze 'use server'. Mozna to robić także bezpośrednio w Server Components ale zaleca się robienie akcji w oddzielnych plikach

Walidacja danych
Przez wysłaniem danych do bazy należy sprawdzić typy danych. Do walidacji wykorzystujemy bibliotekę Zod.

Revalidate and redirect
    Next ma client-side router cache ktory przechowuje podstrony w przegladarce, co pozwala na szybkie przechodzenie miedzy zakladkami,
    Przez to ze zmieniamy dane powinnysmy wyczyscic cache aby na podstronie ktora je wyswietla pojawily sie aktualne dane. Uzywamy do tego revalidatePath()


Error handling
    Obsługę błędów robimy za pomocą try{} catch{}. Stronę do wyświetlania błędów robimy tworząć w folderze plik error.tsx, który musi byc client-component, czyli dajemy 'use client'.
    Komponent error dostaje 2 propsy - error (ktory jest natywnym obiektem js Error) i reset (ktory jest funkcja sluzaca do re-renderowania trasy i resetu bledu )

    Innym sposobem jest uzywanie funkcji notFound, gdy error,tsx jest uzyteczny w obsludze wyjatkow to notFound jest uzywany gdy chcemy pobrac dane ktore nie istnieja. W funkcji pobieracej dane robimy if(!invoice) {notFound()} i tworzymy UI obsługi tego błedu w pliku not-found.tsx

Accesibility
    Odnosi się to do projektowania aplikacji, tak aby wszyscy mogli ich używać, czyli niewidomi itp. Wiecej o tym tutaj https://web.dev/learn/accessibility/
    ESLint
    Konfiguracja ESLint w next zawiera eslint-plugin-jsx-a11y, który pomaga w wyłapywaniu problemów z dostępnością, np. jeżeli w kodzie nie będzie alt przy obrazach lub atrybuty aria-* i role będą użyte nieprawidłowo, to wtyczka poinformuje nas o tym.
    1. pnpm add -D eslint eslint-config-next - instaluje ESLint
    2. Robimy plik eslint.config.mjf 
    3. dodajemy sobie skrypt w package.json w "scripts" - "lint": "eslint ."
    4. Robimy pnpm lint i jezeli nie mamy zadnych bledow ani ostrzeżen to znaczy,że jest w porzadku

    Poprawianie accessibility:
    1. Używanie semantycznego html, czyli <input>, <option> itp. zamiast <div>
    2. Labelling - używanie <label> i w nich atrybutu htmlfor, aby każe pole        formularza miało opisujący je label
    3. Focus Outline - pola powinny być ostylowane aby miały outline gdy są focusowane, zaznacza to wizualnie jaki element na stronie jest obecnie aktywny i pomaga w dostępności dla osób używających klawiatury i czytników ekranu.

    Client-Side form validation
    Dodanie np. required do input, select itp. któro zapobiega wysyłaniu pustych pól 

    Server-Side validation
    Używając walidacji po stronie serwera:  
        - upewniasz sie, że twoje dane mają poprawny format przed wysłaniem ich do bazy danych
        - zmniejszasz ryzyko złośliwych użytkowników, którzy będą probować przejść walidacje po stronie klienta
        - jedno źródło prawdy uznawane za poprawne dane
    Robi się to używając hooka useActionState, który działa tylko na komponentach klienckich, więc należy wstawić 'use-client'. Działa on podobnie jak useState, przy przesłaniu formularza zawartość state się zmienia i pojawiają się w niej aktualne błędy walidacji, lub błędy systemowe np. połączenia z bazą danych, które następnie wyświetlamy robiąc np. state.errors?.status.map(err => ...) bo zazwyczaj jest to w formacie
    {errors: {…}, message: 'Missing Fields. Failed to Create Invoice.'}
        errors: 
        customerId: ['Please select a customer']
        status: ['Please select an invoice status']
        [[Prototype]] : Object
        message: "Missing Fields. Failed to Create Invoice."
    Ważne jest dodanie do obiektu ktory wyswietla nam komunikat pola aria-describedby = "status-error" i do elementu formularza np. input czy select atrybutu id="status-error" (aria-describedby i id musza sie zgadzac analogicznie dla odpowiadajacych sobie elementow), aby ludzie z czytnikami ekranów wiedzieli ze jest to blad walidacji formularza. Dodaje sie jeszcze aria-live="polite", czyli instrukcja dla czytników, mowiaca ze jesli zawartosc tego sie zmieni to zeby poinformowac uzytkownika o tym, ale nie przeszkadzajac mu w tym co robi i aria-atomic="true" aby zawsze czytało calosc komunikatu, nawet jesli zmieni sie minimalna czesc

Authentication
    Strony często oferują 2-etapowe weryfikacje 2FA, ktore wysylaja kod weryfikacyjny ma twoj telefon lub uzywaja oddzielnych aplikacji jak Google Authenticator

    Authentication to upewnianie się, że uzytkownik jest tym którym mówi, za pomocą loginu i hasła

    Autoryzacja jest następnym krokiem, gdy użytkownik już potwierdzi swoją tożsamość, autyrzacja decyduje z jakiej części aplikacji użytkownik może korzystać

    W next można wykorzystać NextAuth.js. Pomaga on w zarządzaniu sesjami, logowaniu i innych rzeczach.