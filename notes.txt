Link
Dzieki tagom Link używanym zamiast <a>, używami client-side navigation dzięki czemu przechodzenie między podstronami nie powoduje pełnego przeładowania strony, re-renderowane są tylko elementy, które uległy zmianie 

Data Fetching

1. Przez API
    Sytuacje, w których używami API:
    - Używamy third-party, czyli oddzielnych serwisów dostarczających API
    - Bierzemy dane od użytkownika, które powinny być przesyłane za pomocą api, aby uniknąć różnych problemów związanych z bezpieczeństwem i uniknąć np. SQL Injection, za pomocą walidacji danych itp.
    W Next.js możemy tworzyć API endpoints za pomocą Route Handlers. Pliki routes pozwalają nam na tworzenie różnych funkcji obsługujących różne metody HTTP, np. GET, POST, PUT, DELETE.
    export async function GET(request: Request) {}
    
    export async function HEAD(request: Request) {}
    
    export async function POST(request: Request) {}
    
    export async function PUT(request: Request) {}
    
    export async function DELETE(request: Request) {}
    
    export async function PATCH(request: Request) {}
    
    // If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.
    export async function OPTIONS(request: Request) {}

    Parametr request to obiekt typu NextRequest, będący rozszerzeniem standardowego request, który dostarcza więcej kontroli nad nadchodzącym zapytaniem http jak dostęp do cookies i URL object

2. Przed database queries
    PRzy relacyjnej bazie danych jak postresql, możemy robić to za pomocą SQL lub ORM 
    Kiedy tworzymy database queries:
    - Tworzymy endpointy API, musimy napisać logikę obsługi bazy danych
    - Gdy używamy React Server components, możemy pisać queries bezpośrednio w komponencie, ponieważ są one wykonywane po stronie serwera a nie klienta

Biblioteka postgres.js dostarcza zabezpieczenia przeciw SQL Injection

1. Normalne wykonywanie zapytań
    Zapytania data requests mogą przypadkowo blokować się nawazajem, powodująć request waterfall
        Co to ? 
        Wodospad odnosi się do kolejności  wykonywania zapytań polegającej na tym, że następne zapytanie może zacząć się tylko jeśli poprzednie dostało swoje dane.
        Czyli robimy np. await fetchData(), a potem mamy await fetchData2(), czyli najpierw wykonuje sie zapytanie 1 i następne czekają na jego zakończenie

2. Parallel data fetching, czyli równoległe pobieranie danych
    Sposób zapobiegania Wodospadom, polegający na jednoczesnym wykonywaniu zapytań. Czyli:
    1. Tworzysz obiekty Promise :  const data1 = sql'Select * from clients'; const data2 = .....
    2. Potem wykonujesz te zapytania wszystkie naraz za pomocą Promise.all()
        const allData = await Promise.all([ data1, data2, data3 ])

    Dzięki temu ładowanie strony i wszystkich danych jest szybsze, ale nie używamy tego jak np. następne dane zależą od poprzednich czyli najpierw pobieramy uzytkownika, a potem np. jego znajomych, ponieważ najpierw musimy znać użytkownika aby dostać się do jego znajomych

Static Rendering
Przy statycznym renderowaniu, dane pobierane są na serwerze w trakce build time, a nie przy każdym zapytaniu.
Używa się go gdy robimy UI bez danych pobieranych lub bez danych wymienianych między użytkownikami.

Dynamic Rendering
Strona jest renderowna przy każdym requescie od uzytkownika, a nie raz na jakis czas

Static używamy gdy robimy np. stron e wizytowke, jakiegos bloga itp. gdzie dane nie muszą być aktualizowane często, a Dynamic gdy mamy np. taki dashboardze statystykami i chcemy aby były one na bieżąco atkuzalizowane.

Problem z Dynamic jest taki, że pochłania więcej zasobów serwera, poniewaz strona jest rerenderowana przy każdym requescie i strona jest tak szybka jak nasz najwolniejszy fetch(), ponieważ dopóki dane nie zostaną pobrane to strona się nie wyswietli.


Streaming
    Streaming pozwala na przesyłanie danych do klienta w kawałkach, a nie w całości, dzięki czemu slow data requests nie blokują nam ładowana strony, dzięki czemu użytkownik widzi wcześniej już UI i pojedyncze elementy, a nie musi czekać aż całość się załaduje
    Działa to dobrze w Reactowymi komponentami, ponieważ każdy komponent może być przesyłany osobno jako kawałek danych.
    Jak sie robi Streaming w nextjs ?
        1. Uzywamy mechanizmu React Suspense, tworząc loading.tsx na poziome naszej strony, który renderuje się natychmiastowo i automatycznie tworzy za nas <Suspense>
        2. Streaming na poziomie komponentu - można streamować tylko fragment strony, za pomocą <Suspense>, czyli:
            export default function Page() {
                return (
                    <>
                    <Header />

                    <Suspense fallback={<p>Loading comments...</p>}> //komponent Comments jest opakowany w suspense, co skutkuje tym ze nasz komponent header zaladuje sie od razu ale po prostu w miejscu komponentu Comments bedziemy miec "Loading comments..." wyświetlony na czas ładowania.
                        <Comments />
                    </Suspense>
                    </>
                )
            }

Używanie URL params 
URL params to /dashboard?query=apple&page=2 parametry po znaku "?", czyli query = apple i page = 2
Za ich pomocą możemy zarządzać search state, czyli zamiast trzymac stan wyszukiwania przez useState() to trzymamy go w url, czyli ...?query=apple
Dlaczego uzywać ?
    1. Bookmarkable i shareable - bez url params parametr wyszukiwania zniknie po odswiezeniu strony, bedzie default
    2. SSR - serwer widzi url, a nie widzi React state, więc bez url params nie jest mozliwy server side Rendering
    3. Analytics and tracking - wyszukiwania zapisują się w logach, więc można śledzić zachowanie użytkowników bez dodatkowej logiki po stronie klienta 
Używanie:
    - useSerachParams - pozwala na dostęp do parametrów z adresu URL
    - usePathname - pozwala odczytać obecny URL czyli jak mamy /dashboard/invoices to zwróci nam '/dashboard/invoices'
    - useRouter - pozwala zmieniać trasę URL i nawigować między stronami z poziomu kodu, czyli po prostu zmieniać storny


DEBOUNCING
Wazne przy wyszukiwaniu, zeby nie pobierac danych przy kazdym wpisaniu znaku, uzywa sie do tego use-debounce

Next i Server Actions
    Server Actions pozwala na wywoływanie asynchronicznego kodu na serwerze, dzieki czemu eliminują potrzebę tworzenia API do CRUD (jeżeli modyfikujemy i pobieramy dane po stronie klienckiej to powinno byc to robione przez API)
    Jak używamy?
        Tworząc funkcję np. w pliku actions.ts markujemy funkcje jako server actions dodajac na górze 'use server'. Mozna to robić także bezpośrednio w Server Components ale zaleca się robienie akcji w oddzielnych plikach

Walidacja danych
Przez wysłaniem danych do bazy należy sprawdzić typy danych. Do walidacji wykorzystujemy bibliotekę Zod.

Revalidate and redirect
    Next ma client-side router cache ktory przechowuje podstrony w przegladarce, co pozwala na szybkie przechodzenie miedzy zakladkami,
    Przez to ze zmieniamy dane powinnysmy wyczyscic cache aby na podstronie ktora je wyswietla pojawily sie aktualne dane. Uzywamy do tego revalidatePath()


Error handling
    Obsługę błędów robimy za pomocą try{} catch{}. Stronę do wyświetlania błędów robimy tworząć w folderze plik error.tsx, który musi byc client-component, czyli dajemy 'use client'.
    Komponent error dostaje 2 propsy - error (ktory jest natywnym obiektem js Error) i reset (ktory jest funkcja sluzaca do re-renderowania trasy i resetu bledu )

    Innym sposobem jest uzywanie funkcji notFound, gdy error,tsx jest uzyteczny w obsludze wyjatkow to notFound jest uzywany gdy chcemy pobrac dane ktore nie istnieja. W funkcji pobieracej dane robimy if(!invoice) {notFound()} i tworzymy UI obsługi tego błedu w pliku not-found.tsx



